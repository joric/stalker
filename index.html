<!DOCTYPE html>
<html lang="en">
<head>
<title>Joric's Stalker</title>

<meta charset="utf-8">
<meta name="viewport" content="initial-scale=1.0, user-scalable=no">
<meta name="mobile-web-app-capable" content="yes">
<link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 512 512'%3E%3Cpath d='M464 256A208 208 0 1 0 48 256a208 208 0 1 0 416 0zM0 256a256 256 0 1 1 512 0A256 256 0 1 1 0 256zm306.7 69.1L162.4 380.6c-19.4 7.5-38.5-11.6-31-31l55.5-144.3c3.3-8.5 9.9-15.1 18.4-18.4l144.3-55.5c19.4-7.5 38.5 11.6 31 31L325.1 306.7c-3.2 8.5-9.9 15.1-18.4 18.4zM288 256a32 32 0 1 0 -64 0 32 32 0 1 0 64 0z'/%3E%3C/svg%3E" />

<meta property="og:image" content="https://joric.github.io/stalker/images/thumbnail.jpg" />
<meta property="og:site_name" content="Joric" />
<meta property="og:type" content="object" />
<meta property="og:title" content="Joric's Stalker" />
<meta property="og:description" content="Interactive Map" />

<link rel="stylesheet" href="css/main.css" />
<link href="js/lib/font-awesome/css/all.min.css" rel="stylesheet">
<link href="js/lib/maptalks-gl/maptalks.css" rel="stylesheet">
<script type="text/javascript" src="js/lib/maptalks-gl/maptalks-gl.js"></script>
<script type="text/javascript" src="js/lib/fuse/fuse.js"></script>

</head>
<body>

<div id="rank-selector">
  <select>
  </select>
</div>

<div id="language-selector">
  <select>
  </select>
</div>


<div tabindex=0 id="map"></div>

<div class="search-container">
  <div class="search-box">
    <input tabindex=1 type="text">
    <span class="search-icon search-submit" title="Search">&#128269;&#xFE0E;</span>
    <span class="search-icon search-cancel" title="Cancel">&times;</span>
  </div>
</div>

<div id="map-tooltip" class="arrow-left"></div>

<template id="popup-template">
<div id="popup" class="popup">
  <div class="popup-content-wrapper">
    <div class="popup-content">
      <div id="popup-title">Popup Title</div>
      <div id="popup-subtitle">Popup Subtitle</div>
      <div id="popup-note">Popup Note</div>
      <div id="popup-subnote" class="collapsed">Popup Subnote</div>
      <div id="popup-data" class="collapsed"></div>
      <div id="popup-data-toggle" data-toggle="collapse" data-target="popup-data"><hr/></div>
      <div class="popup-controls">
        <input id="popup-found" type="checkbox">
        <label id="popup-found-label" for="popup-found" title="Toggle found">Found</label>
        <a class="popup-link" id="popup-wiki-link" href="#" target="_blank" title="Fallout London Wiki"><i class="fa fa-brands fa-wikipedia-w"></i></a>
        <a class="popup-link" id="popup-map-link" href="#" target="_blank" title="Copy Map Link to Clipboard"><i class="fa fa-link"></i></a>
        <a class="popup-link" id="popup-form-id-link" href="#" target="_blank" title="Copy Marker SID to Clipboard"><i class="fa fa-hashtag"></i></a>
        <a class="popup-link" id="popup-marker-id-link" href="#" target="_blank" title="Copy Marker Location to Clipboard"><i class="fa fa-location-crosshairs"></i></a>
      </div>
    </div>
  </div>
  <div class="popup-tip-container"><div class="popup-tip"></div></div>
  <a id="popup-close" class="popup-close-button">&times;</a>
</div>
</template>

<div id="alert" class="closed">Copied To Clipboard</div>

<script>
let maxZoom = 19;
let enableAltitude = false;
let heightFactor = 1.0;
let iconSize = 48;
let startPitch = 0;
let startZoom = 2;
let defaultPitch = 45;
let autoAltitude = true;
let textSize = 18;
let labelGroups = ['regions'];//, 'locations'];

let zoomGroups = {
  'polygons':[-99,99], 'regions':[-99,2],
  'hubs': [2,99], 'bases': [2,99],
  'circles':[2,6], 'locations': [2,99],
  'actors': [3,99], 'lines':[3,99],
  'stashes':[4,99],
  'items':[5,99], 'enemies':[6,99], 'anomalies':[6,99],
  'misc':[7,99],
  'helpers': [8,99],
};

let foundOpacity = 0.25;
let arrowStyle = [2,3];

let scaleZ = 0.1; // postprocess coordinates beacuse enableAltitude and heightFactor doesn't seem to work at all

//weird shit's happening. lines seem to be flat rectangles so they dissapear at certain camera angles
let enableTeleportLines = true;
let enableHeightLines = false;
let enableActorLines = true;
let enableItemLines = true;

let lineWidth = 2;
let lineColor = '#fff';

let tooltipShowTimer = null;
let tooltipHideTimer = null;
let tooltipHideDelay = 1;
let tooltipShowDelay = 1;

let groupLayer = null;
let map = null;

let types = {};
let icons = {};
let lang = {};
let markers = {};
let regions = {};

let actors_lookup = {};
let items_lookup = {};

let mapParam = {};
let markersData = null;
let regionsData = null;

let tileset_base = location.protocol === 'file:' ? '../stalker2_tileset' : 'https://joric.github.io/stalker2_tileset';

let localDataName = 'joricsStalkerMapsGL';
let localData = JSON.parse(localStorage.getItem(localDataName))||{};
let mapId = 's2hoc';

let searchControl = null;

let localImages = {};
let firstRun = false;

const capitalize = s => s[0].toUpperCase()+s.slice(1);
const cmpAlphaNum = (a,b) => a[0].localeCompare(b[0], 'en', { numeric: true });

function scaleCoordinate(c) {
  return scaleZ < 1.0 ? {x: c.x, y:c.y, z:c.z*scaleZ} : c;
}

function scaleCoordinateArray(c) {
  return scaleZ < 1.0 ? [ c[0], c[1], c[2]*scaleZ] : c;
}

class CustomTooltip extends maptalks.ui.ToolTip {
    constructor(options) {
        super(options);
    }

    /*
    buildOn() {
        // Create a DOM element for the tooltip
        const tooltip = document.createElement('div');
        tooltip.className = 'custom-tooltip';
        tooltip.innerHTML = this.options.content;
        return tooltip;
    }


    getOffset() {
        // Adjust the offset of the tooltip relative to the marker
        return new maptalks.Point(0,0);
    }
    */
}

function loadMap() {

  if (!localData[mapId]) {
    localData[mapId] = { language: 'en', activeItems: {'bases':true, 'hubs': true, 'locations': true, 'stashes': true, 'regions': true, 'items': true, 'enemies': true, 'circles': true, 'polygons': true} };
  }

  if (!localData[mapId].markedItems) {
     localData[mapId].markedItems = {};
  }

  settings = localData[mapId];

  settings.baseLayer = settings.baseLayer || 'PDA';
  settings.language = settings.language || 'en';
  settings.searchText = settings.searchText || '';
  settings.rank = settings.rank || 'Master';

  searchControl = document.querySelector('.search-box input');

  searchControl.value = settings.searchText || '';

  //console.log('current zoom:', settings.zoom);
  let scrollWheelZoom = true; // maptalks uses fractional zoom by default
  //let scrollWheelZoom = false;

  let w = h = 812900;
  let center = [w/2, h/2];
  let [left,top,right,bottom] = [0, 0, w, h];
  let tileSize = 512;

  if (!settings.center) {
    [settings.zoom, settings.pitch, settings.bearing, settings.center] = [startZoom, startPitch, 0, center];
  }

  map = new maptalks.Map('map', {

    heightFactor: heightFactor,

    zoom: settings.zoom,
    pitch: settings.pitch,
    bearing: settings.bearing,
    center: settings.center,
    maxPitch: 80,

    maxZoom: maxZoom,

    scrollWheelZoom: scrollWheelZoom,

    spatialReference : {
      projection : 'identity',
      fullExtent : { top: top, left: left, bottom: bottom, right: right }, // mandatory to hide 404
      resolutions: Array.from({length: maxZoom + 1},(_,i) => w / tileSize / (1<<i)), // mandatory zoom levels
    },

    baseLayer: new maptalks.GroupTileLayer('Base TileLayer', [

      new maptalks.TileLayer('PDA', {
        maxAvailableZoom: 7,
        urlTemplate: `${tileset_base}/tiles/{z}/{x}/{y}.jpg`,
        repeatWorld: false,
        tileSize: 512,
        visible: settings.baseLayer == 'PDA',
      }),

      new maptalks.TileLayer('GlobalMap', {
        maxAvailableZoom: 5,
        urlTemplate: `${tileset_base}/extras/wb/{z}/{x}/{y}.jpg`,
        repeatWorld: false,
        tileSize: 512,
        visible: settings.baseLayer == 'GlobalMap',
      }),

      new maptalks.TileLayer('LDScheme', {
        maxAvailableZoom: 3,
        urlTemplate: `${tileset_base}/extras/ld/{z}/{x}/{y}.png`,
        repeatWorld: false,
        tileSize: 512,
        visible: settings.baseLayer == 'LDScheme',
      }),

    ]),

    zoomControl: {
      //position  : 'bottom-right',
      //position  : 'top-right',
      position  : {bottom: 70, right: 20},
      zoomLevel : false,
    },

    //seamlessZoom: true,
    doubleClickZoom: false,

    //maxExtent: extent,

    /*
    // overview is broken, due to a flat projection I guess
    overviewControl: {
      position: 'bottom-left',
      size: [240,135],
      level: 10,
      symbol: {

        'lineColor': '#fff',    // Border color
        'lineWidth': 1.5,            // Border width
        'polygonFill': '#fff',  // Fill color
        'polygonOpacity': 0.0,      // Fill opacity
        'lineOpacity': 0.5,
      },
    },
    */

    attribution: {
      //position: {top: -50},
    },
  });


  // Function to handle zooming
  function handleZoom(event) {
    event.preventDefault(); // Prevent the default scroll behavior
    const currentZoom = map.getZoom();
    const zoomStep = 1; // Define the zoom step
    if (event.deltaY < 0) {
      // Scroll up, zoom in
      map.setZoom(currentZoom + zoomStep);
    } else {
      // Scroll down, zoom out
      map.setZoom(currentZoom - zoomStep);
    }
  }

  // Add event listener for mouse wheel
  if (!scrollWheelZoom) map.getContainer().addEventListener('wheel', handleZoom);

  map.on('viewchange', e=> {
    settings.center = [e.new.center[0],e.new.center[1]];
    settings.bearing = e.new.bearing;
    settings.pitch = e.new.pitch;
    settings.zoom = e.new.zoom;
    if (enableAltitude && autoAltitude) {
      groupLayer.setOptions({enableAltitude: map.getPitch()!=0});
    }
    //console.log('zoom', settings.zoom);
    saveSettings();
  });


  let gap = w/2;
  let extent = new maptalks.Extent(left-gap, top-gap, right+gap, bottom+gap);
  map.setMaxExtent(extent);

  new maptalks.TileLayer('Stalker1', {
    maxAvailableZoom: 3,
    urlTemplate: `${tileset_base}/extras/s1/{z}/{x}/{y}.png`,
    repeatWorld: false,
    tileSize: 512,
    visible : false,
  }).addTo(map);

  groupLayer = new maptalks.GroupGLLayer('Features',[], {
    enableAltitude: enableAltitude,
    sortByDistanceToCamera: true,
    forceRenderOnMoving: true,
    forceRenderOnRotating: true,
  }).addTo(map);

  setTimeout(function() {
    if (enableAltitude && autoAltitude) {
      groupLayer.setOptions({enableAltitude: map.getPitch()!=0});
    }
  },500);

  document.querySelector('.search-cancel').onclick = e=> {
    clearFilter();
    saveSettings();
    updateView();
  };

  document.querySelector('.search-submit').onclick = e=> {
    updateSearch(searchControl.value||'', false);
  };

  map.on('mousedown', function(e) {
    document.getElementById('map').focus(); // needs tabindex on the map element
  });

  map.on('moving', hideTooltip);

  map.on('zooming', e=>{
    hideTooltip();
    updateView();
  });

  map.on('zoomend', e=>{
    updateView();
  });

  map.on('setbaselayer', e=> {
    let layers = map.getBaseLayer().getLayers();
    for (layer of layers) {
      if (layer.isVisible()) {
        settings.baseLayer = layer.getId();
      }
    }
    saveSettings();
  });
}

function addLine(marker, target, c) {
  let pt = target ? target.getCoordinates() : scaleCoordinate( {x: c[0], y: c[1], z: c[2]} );
  let line = new maptalks.LineString([marker.getCoordinates(), pt],{arrowStyle:arrowStyle, symbol:{lineColor: lineColor, lineWidth: lineWidth}});
  line.feature =  marker.feature;
  return line;
}

function addLines(markers) {
  let geometry = [];

  for (m of markers) {

    let marker = m.marker;
    let o = marker.feature.properties;

    if (enableTeleportLines && o.target) {
      geometry.push( addLine(marker, null, m.marker.feature.properties.target) );
    }

    if (enableHeightLines) {
      let c = m.marker.getCoordinates();
      geometry.push( addLine(marker, null, [c.x,c.y,0] ) );
    }

    if (enableActorLines) {
      let target = actors_lookup[o.uaid];
      if (target) {
        geometry.push( addLine(marker, target) );
      }
    }

    if (enableItemLines) {
      let group = items_lookup[o.name];
      if (group && o.name != 'Vodka') {
        for (target of group) {
          // the big issue here is that target may be invisible, needs fixing lines vs zoom levels
          // limit line length here

          let a = marker.getCoordinates();
          let b = target.getCoordinates();
          let dist = Math.sqrt(Math.pow(a.x-b.x,2)+Math.pow(a.y-b.y,2)+Math.pow(a.z-b.z,2));
          if (dist < 50000) geometry.push( addLine(marker, target) );
        }
      }
    }

  }

  let layerId = 'Lines'
  let visible = settings.activeItems[layerId.toLowerCase()] == true;
  let layer = new maptalks.LineStringLayer(layerId, geometry, { visible: visible, sceneConfig: { depthFunc: '<='} });
  addHandler(layer);
  layer.addTo(groupLayer);
}

function addCircles(markers) {
  let geometry = [];

  const defaultSymbol = {
    'lineColor': '#fff',    // Border color
    'lineWidth': 2.5,            // Border width
    'polygonFill': '#fff',  // Fill color
    'polygonOpacity': 0.1,      // Fill opacity
    'lineOpacity': 0.85,
  };

  for (m of markers) {
    let o = m.marker.feature.properties;
    if (o.radius) {

      let color = o.type.includes('Hub') ? '#e8a514' : '#fff';

      //let numberOfShellPoints = Math.min(60, ~~(o.radius / 200));
      var circle = new maptalks.Circle(m.marker.getCoordinates(), o.radius, {
        symbol: {...defaultSymbol, lineColor: color, polygonFill: color},
        properties: {
          //numberOfShellPoints: numberOfShellPoints,
        },
      });
      geometry.push(circle);

      circle.feature = m.marker.feature;
    }
  }

  let layerId = 'Circles'
  let visible = settings.activeItems[layerId.toLowerCase()] == true;
  let layer = new maptalks.PolygonLayer(layerId, geometry, { visible: visible });
  addHandler(layer);
  layer.addTo(groupLayer);
}

function addMarkers(data) {
  console.timeEnd('markers');
  console.log('Total markers:', data.length);

  markersData = data;

  addLines(data);
  addRegions(regions);
  addCircles(data);

  // join markers by group name
  let collection = {};

  for (m of data) {
    if (!collection[m.group]) collection[m.group] = [];
    collection[m.group].push(m.marker);
  }

  let weights = {'regions': 1100, 'hubs': 1000, 'bases': 900, 'locations': 750, 'stashes': 500, 'items': 250, 'anomalies': -900, 'misc': -1000 };
  let groups = Object.keys(collection);

  groups = groups.sort( (a,b)=> (weights[b]||0)-(weights[a]||0) || cmpAlphaNum(a,b))

  //console.log('sorted groups', groups);

  for (const group of groups) {
    let layerName = capitalize(group);
    let geometries = collection[group];
    let visible = settings.activeItems[group] == true;

    layer = new maptalks.PointLayer(layerName, geometries, {
      enableAltitude: enableAltitude,
      sortByDistanceToCamera: true,
      forceRenderOnMoving: true,
      forceRenderOnRotating: true,
      visible: visible,
      sceneConfig: { depthFunc: '<='},
    }).addTo(groupLayer);

    //console.log('created layer', group, 'visible', settings.activeItems[group], geometries.length, 'markers');
    addHandler(layer);
  }

  let LayerSwitcher = new maptalks.control.LayerSwitcher({
    position  : 'bottom-left',
    baseTitle : 'Base Layers',
    overlayTitle : 'Overlays',
    containerClass : 'maptalks-layer-switcher',
  }).addTo(map);

  let name = mapParam.markerName;
  if (name) {
    mapParam = {};
    settings.searchText = name;
  }

  updateSearch(settings.searchText);
}

function findLocation(id) {
  for (m of markersData) {
    let marker = m.marker;
    let o = marker.feature.properties;
    if (id == o.sid) {
      return marker;
    }
  }
}

function jumpToLocation(name) {
  let marker = findLocation(name);
  if (marker) {
    //map.setView({center: marker.getCoordinates(), zoom:8, pitch:0, bearing:0}); // don't change zoom maybe
    map.setView({center: marker.getCoordinates()}); // don't change zoom maybe
    marker.show();
    popupOnClick({target: marker});
    marker.openInfoWindow();
  }
}

// doesn't work in safari
function loadMarkersIdle(data) {
  const features = data.features;
  let currentIndex = 0;
  let result = [];
  function processBatch(deadline) {
    batch = [];
    while (deadline.timeRemaining() > 0 && currentIndex < features.length) {
      let marker = addMarker(features[currentIndex]);
      if (marker) {
        batch.push(marker);
      }
      currentIndex++;
    }
    //console.log(`Processed ${currentIndex}/${features.length} markers`);
    if (currentIndex < features.length) {
      result.push(...batch);
      requestIdleCallback(processBatch); // Schedule the next batch during idle time
    } else {
      result.push(...batch);
      addMarkers(result);
    }
  }
  requestIdleCallback(processBatch, { timeout: 1000 });
}

function loadMarkersBatched(data) {
  const features = data.features;
  const batchSize = 5000;
  let currentIndex = 0;
  let result = [];
  function processBatch() {
    const batch = [];
    const endIndex = Math.min(currentIndex + batchSize, features.length);
    for (; currentIndex < endIndex; currentIndex++) {
      let marker = addMarker(features[currentIndex]);
      if (marker) {
        batch.push(marker);
      }
    }
    result.push(...batch);
    if (currentIndex < features.length) {
      setTimeout(processBatch, 0); // Allow time for browser events
    } else {
      addMarkers(result);
    }
  }
  setTimeout(processBatch, 0); // Start processing asynchronously
}

function loadMarkersSimple(data) {
  let result = []
  for (const feature of data.features) {
    let marker = addMarker(feature);
    if (marker) result.push(marker);
  }
  addMarkers(result);
}

function loadMarkers(data) {
  markers = data;
  console.time('markers');
  loadMarkersBatched(data);
  //loadMarkersSimple(data);
}

function addHandler(layer) {
  const originalShow = layer.show;
  const originalHide = layer.hide;

  // Override the show method
  layer.show = function () {
    // Call the original show method
    originalShow.call(this);
    // Fire a custom 'visibilitychange' event
    this.fire('visibilitychange', { visible: true });
  };

  // Override the hide method
  layer.hide = function () {
    // Call the original hide method
    originalHide.call(this);
    // Fire a custom 'visibilitychange' event
    this.fire('visibilitychange', { visible: false });
  };

  // Listen for the custom 'visibilitychange' event
  layer.on('visibilitychange', function (e) {
    let group = e.target.getId().toLowerCase();
    let show = e.visible;

    if (show) {
      settings.activeItems[group] = true;
    } else {
      delete settings.activeItems[group];
    }

    //console.log(settings);

    saveSettings();

  });
}

function clearSelection() {
  if (window.getSelection) {
    // Modern browsers
    const selection = window.getSelection();
    if (selection.removeAllRanges) {
      selection.removeAllRanges();
    } else if (selection.collapseToEnd) {
      // For older WebKit browsers
      selection.collapseToEnd();
    }
  } else if (document.selection) {
    // Older versions of Internet Explorer
    document.selection.empty();
  }
}

function translate_item(name, verbose=false) {
  name = name.replace('Antirad','AntiRad');
  let title = lang[`sid_items_${name}_name`] || lang[`sid_questItemprototypes_${name}_name`];
  if (!title) {
    let proto = markers.prototypes[name];
    if (proto) {
      if (verbose) console.log(proto);
      let lsid = proto.lsid;
      if (lsid) {
        title = lang[`sid_upgrades_${lsid}_name`] || lang[`sid_questItemprototypes_${lsid}_name`];
      }
    }
  }
  return title || name;
}

function translate(fields, postfix) {
  let prefixes = ['sid_locations_region_','sid_locations_', 'sid_items_','sid_stashes_','sid_questItemprototypes_','sid_items_FArtifact','sid_items_CArtifact','sid_items_AArtifact'];
  for (field of fields) {
    if (lang[field]) return lang[field];
    for (prefix of prefixes) {
      let res = lang[`${prefix}${field}${postfix}`];
      if (res) return res;
    }
  }
}

function getTitleDesc(o) {
  if (o.title || o.description) {
    return [ lang[o.title], lang[o.description] || ''];
  }

  if (o.type=='ESpawnType::Item') {
    return [
      lang[`sid_items_${o.name}_name`] || lang[`sid_questItemprototypes_${o.name}_name`],
      lang[`sid_items_${o.name}_desc`] || lang[`sid_questItemprototypes_${o.name}_desc`],
    ];
  }

  return [o.title, o.desc];
}

function humanReadable(o) {

  let [title, desc] = getTitleDesc(o);

  if (!title || !desc) {
    let prop = getIconProp(o);
    return [ title || lang[o.title || prop.title] || prop.title || o.name,  desc || lang[o.description || prop.description]||''];
  }

  return [title, desc];
}

function setClass(e, set, c) { set ? e.classList.add(c) : e.classList.remove(c);}
function toggleClass(e, c) { if (e.classList.contains(c)) { e.classList.remove(c); return false; } else { e.classList.add(c); return true; }}
function toggleNav(e) { let input = document.querySelector('#search-input'); toggleClass(e.parentElement, 'closed') ? input.blur() : input.focus();}
function toggleVisibility(a) { [].forEach.call(a, function(e) { toggleClass(document.querySelector(e), 'collapsed'); }) }
const cmpNum = (a,b)=> b[1]!=a[1] ? (b[1]-a[1]) : a[0].localeCompare(b[0]);

function copyToClipboard(text) {
  let input = document.body.appendChild(document.createElement("input"));
  input.value = text;
  input.focus();
  input.select();
  document.execCommand('copy');
  input.parentNode.removeChild(input);
  document.getElementById('alert').classList.remove('closed');
  setTimeout(function(e){ document.getElementById('alert').classList.add('closed') },1500);
}


function canonical(id) {
  return id ? id.slice(2) : '';
}

function getBaseURL() {
  return window.location.href.replace(/#.*$/,'');
}

function getMapURL(id) {
  return getBaseURL() + '#' + encodeURIComponent(id);
}

function getWikiURL(title) {
  if (title.startsWith('«') && title.endsWith('«')) title = title.slice(1,-1);
  //title = title.split(' ').map(capitalize).join(' ')
  return wikiPrefix + (settings.language=='en' ? '': settings.language+'/') + 'wiki/' + encodeURIComponent(title);
}

function wikify(o) {
  let location_id = o.title;
  return location_id.replace(/[^A-Za-z0-9\s]/g, '').trim().replace(/\s+/g, '_');
}

let wikiPrefix = 'https://stalker.fandom.com/';

let copyLink = e=>{ copyToClipboard(e.target.href); return false; };

function renderPhoto(o) {
  if (!o.material) {};

  let lookup = {
    'MI_pos_photos_01_a_01': 1,
    'MI_pos_photos_01_a_02': 1,
    'MI_pos_photos_01_b_01': 2,
    'MI_pos_photos_01_b_02': 2,
  };

  let t = lookup[o.material];

  if (!t) return {};

  let i = o.image_index || 0;
  let iw = ih = 4096;
  let cw = 14;
  let ch = 10;
  let cx = ~~(i%cw);
  let cy = ~~(i/cw);
  let w = ~~(iw/cw);
  let h = ~~(ih/ch);
  let tx = Math.round(iw * cx / cw);
  let ty = Math.round(ih * cy / ch);

  let idx = (t-1) * cw * ch + i + 1;
  let title = lang[`sid_misc_QIO_Photo`] + ' ' + idx;

  return {
    title: title,
    photo: `<div style="width:${w}px;height:${h}px;background-image: url(images/photos/T_pos_photos_0${t}_D.jpg);background-position: -${tx}px -${ty}px"></div>`,
  }
}

function renderItem(feature, extended=false, verbose=false) {
  let o = feature.properties;

  let prop = getIconProp(o);

  let [title, description] = humanReadable(o);

  let group = prop.group || 'misc';
  let category = lang[prop.category] || prop.category || lang[prop.title] || group;
  let location = '';

  if (o.lsid) {
    title = lang[`sid_questItemprototypes_${o.lsid}_name`];
    description = lang[`sid_questItemprototypes_${o.lsid}_description`];
  }

  if (o.clue) {
    title = lang[`sid_stashes_${o.clue}_name`];
    description = lang[`sid_stashes_${o.clue}_description`];
  }

  let info = {
    title: title || category || o.type,
    category: category,
    location: location,
    group: group,
    description: description,
    prop: prop,
  };

  info = {...info, ...renderPhoto(o) };

  if (!extended) return info; // region markers need title

  if (!feature.geometry) return info;

  let c = feature.geometry.coordinates;
  //let teleport = `${c[0]} ${c[1]} ${c[2]}`;
  //let location = `XTeleportTo ${teleport}`
  let currentRegion = getRegionName({x: c[0], y:c[1], z:c[2]}, regionsData);
  info.location = lang[`sid_locations_region_${currentRegion}_name`];

  if (o.references) {
    for (const name of o.references) {
      if (name.includes('SetQuestGiver')) {
        const quest = name.split('_SetQuestGiver')[0].replace('_P','');
        let title = lang[`sid_journal_${quest}_Name`];
        if (title) {
          info.quest = title;
        }
      }
    }
  }

  if (o.faction) {
    let title = lang[`sid_misc_answer_faction_${o.faction}`];
    if (title) {
      info.category = title;
    }
  }

  // add items
  if (o.items) {
    let items = [];
    for (const name of o.items) {
      items.push(translate_item(name));
    }
    info.items = items;
  }

  // we need to group rank-prefixed spawns by rank
  // e.g. 3612452147E4E0C44DED9B84F755461F has two Newbie entries

  let current_rank = settings.rank;
  let diff = 'Normal';
  let matching_rank = null;

  let rank_score = { 'Newbie': 1, 'Experienced': 2, 'Veteran': 3, 'Master': 4 };

  function getGeneratorItems(gen_name, rank, diff) {
    let items = [];

    if (!markers.generators[gen_name]) {
      gen_name = markers.prototypes[gen_name] && markers.prototypes[gen_name].proto;
    }

    let generators = markers.generators[gen_name]||[];

    //console.log(gen_name, generators);

    // pre-filter ranks
    let best_rank = null;
    for (const generator of generators) {
      if (generator.rank && rank_score[current_rank] >= rank_score[generator.rank.split('::').pop()]) best_rank = generator.rank;
    }

    for (const generator of generators) {
      if (generator.rank && best_rank && generator.rank!=best_rank) continue;

      for (const group of (generator.groups || [])) {

        // calculate count of items in pack
        let total = 0;
        for (const [name, props] of Object.entries(group.items||{})) {
          if (group.category!='SubItemGenerator') {
            total ++;
          }
        }

        let random_choice = ~~(Math.random()*total);

        let count = 0;

        for (const [name, props] of Object.entries(group.items||{})) {

          if (group.category=='SubItemGenerator') {
            items.push(...getGeneratorItems(name, rank, diff));
          } else {

            // add one random item for now
            if (count==random_choice) {
              items.push({name: name, generator: gen_name, category: group.category, props: props });
            }
            count ++;
          }
        }

      }
    }

    //console.log(items);

    return items;
  }

  if (o.spawns) {
    let items = [];

    // ranked spawns are structured the way we only have one matching rank
    for (name of o.spawns) {
      if (name.includes(':')) {
        [rank, name] = name.split(':');
        if (rank_score[current_rank]>=rank_score[rank]) matching_rank = rank;
      }
    }

    for (name of o.spawns) {
      let rank = null;
      if (name.includes(':')) {
        [rank, name] = name.split(':');
        if (rank!= matching_rank) continue;
      }
      items.push(...getGeneratorItems(name, rank || current_rank, diff));
    }

    info.groups = items;
  }


  // add upgrade thingy, if any
  if (info.groups) {

    for (prop of info.groups) {
      let name = prop.name;
      let proto = markers.prototypes[name];
      if (proto) {
        let lsid = proto.lsid;
        let title = lang[`sid_upgrades_${lsid}_name`];
        let desc = lang[`sid_upgrades_${lsid}_description`];

        if (title) {
          let items = [];
          for (item of (proto.compatible||{})) {
            let s = lang[`sid_items_${item}_name`];
            if (s) items.push(s);
          }
          let items_str = items.join(', ');
          info.upgrade = `<b>${title}</b><div class="small padded">${items_str}</div>`;
        }
        if (desc) {
          info.upgrade = (info.upgrade||'') + `${desc}`;
        }
      }
    }
  }

  // add PDA description
  if (o.proto && o.proto.startsWith('QuestItem_Note') ) {
    let desc = lang[`sid_questItemprototypes_${o.name}_description`];
    if (desc) {
      info.note = desc;
    }
  }

  if (isLocked(o)) info.title = lang['sid_misc_hint_cantopen'];

  return info;
}

function getSpawnContent(o, name) {
  let rank = null;

  if (name.includes(':')) {
    [rank, name] = name.split(':');
  }

  section = 'generators'

  let data = markers[section][name];

  for ( key of Object.keys( data||{} )) {
    if (markers[section][name][key].type == 'generator') {
      //console.log(name, '->', item);
      return markers[section][key];
    }
  }

  return data;

}

function customReplacer(key, value) {
  if (value && typeof value === 'object') {
      const depth = this.depth || 0;
      if (depth === 1) {
          return JSON.stringify(value);
      }
      return { ...value, depth: depth + 1 };
  }
  return value;
}

function getMarkerSize(marker) {
  let symbol = marker.getSymbol();
  if (symbol instanceof Array) {
    symbol = symbol[0];
  }
  return symbol.markerWidth || 32;
}

function setMarkerSize(marker, size) {
  return; // do not do it yet
  let symbol = marker.getSymbol();
  let prop = { markerWidth: size, markerHeight: size };
  let textProp = { textSize: textSize * 1.0 };
  marker.setSymbol((symbol instanceof Array) ? [{...symbol[0], ...prop}, {...symbol[1], ...textProp}] : {...symbol, ...prop});
}

function popupOnClick(e) {
  //console.log('clicked', e.target.feature);

  hideTooltipExt(e);

  let marker = e.target;

  let feature = marker.feature;
  let o = marker.feature.properties;

  const popup = document.querySelector('#popup-template').content.cloneNode(true);

  let info = renderItem(marker.feature, true, true);

  popup.querySelector('#popup-title').textContent = info.title;
  popup.querySelector('#popup-title').title = o.name;
  popup.querySelector('#popup-subtitle').textContent = info.category;
  popup.querySelector('#popup-note').textContent = info.location;

  let div = popup.querySelector('#popup-subnote');
  div.replaceChildren();
  div.classList.remove('collapsed');

  if (info.description) {
    let hr = document.createElement('hr');
    let content = document.createElement('div');
    content.textContent = info.description;
    div.appendChild(hr);
    div.appendChild(content);
  }

  let rank = 'Master';

  function createTag(color, name, title, tooltip, action) {
    let span = document.createElement('a');

    span.textContent = title;
    span.title = tooltip;
    span.className = 'tag-item';

    if (action.startsWith('http')) {
      span.href = action;
      span.target = '_blank';
    } else {
      span.setAttribute('action', action);
      span.onclick = function(e) { copyToClipboard(  `${e.target.getAttribute('action')}`  )  };
    }

    let colors = ['#eee', '#dde', '#ded', '#eed', '#ede'];
    if (color>0) {
      span.style.backgroundColor = colors[(color-1) % colors.length];
    }

    return span;
  }


  if (o.spawns) {
    let container = document.createElement('div');
    container.classList.add('scrollbar','tag-container');

    let groups = {}

    for (const data of (info.groups||{})) {
      groups[data.generator] = true;
      let color = Object.keys(groups).length;
      let name = data.name;
      let title = translate_item(name);
      let tooltip = [title, name, settings.rank, data.generator, JSON.stringify(data.props), data.category].filter(e=>e).join('\n');
      container.appendChild(createTag(color+1, name, title, tooltip, getWikiURL(title)));
    }

    div.appendChild(document.createElement('hr'));
    div.appendChild(container);
  }

  if (o.references) { // add signals
    let container = document.createElement('div');
    container.classList.add('scrollbar','tag-container');
    for (const name of o.references) {
      container.appendChild(createTag(5, name, name, name, `XStartQuestNodeBySID ${name}`));
    }
    div.appendChild(document.createElement('hr'));
    div.appendChild(container);
  }


  if (o.items) { // add items
    let container = document.createElement('div');
    container.classList.add('scrollbar','tag-container');
    for (const name of o.items) {
      let title = translate_item(name);
      container.appendChild(createTag(0, name, title, name, name));
    }
    div.appendChild(document.createElement('hr'));
    div.appendChild(container);

  }


  let content =  '';

  /* // too tall
  if (info.upgrade) {
    content += `<hr/>${info.upgrade}`;
  }
  */

  if (o.keycode) {
    content += `<hr/>Keycode: ${o.keycode}`;
  }

  if (info.photo) {
    content += `<hr/>${info.photo}`;
  }

  if (content) {
    let el = document.createElement('div');
    el.innerHTML = content;
    div.appendChild(el);
  }

  popup.querySelector('#popup-data').innerHTML = '<hr/><pre>'+JSON.stringify(o, null, 2) + '</pre>';

  popup.querySelector('#popup-data-toggle').onclick = function(e) {
    let data_id = document.querySelector('#popup-data-toggle').getAttribute('data-target');
    settings.debugMode = !toggleClass(document.querySelector('#'+data_id),'collapsed');
    saveSettings();
  };

  setClass(popup.querySelector('#popup-data'), settings.debugMode!=true, 'collapsed');

  popup.querySelector('#popup-close').onclick = function() {  e.target._infoWindow.hide(); };

  let c = null;

  let t = feature.geometry.coordinates;
  let teleport = `XTeleportTo ${t[0]} ${t[1]} ${t[2]}`
  c = popup.querySelector('#popup-marker-id-link')
  c.href = '#' + teleport;
  c.title = `Copy Coordinates (${teleport})`;
  c.onclick = function(e){ copyToClipboard(e.target.href.split('#')[1].replaceAll('%20',' ')); return false; };

  c = popup.querySelector('#popup-form-id-link');
  c.href = '#' + o.sid;
  c.title = `Copy SID (${o.sid})`;
  c.onclick = function(e){ copyToClipboard(e.target.href.split('#')[1]); return false; };

  c = popup.querySelector('#popup-map-link');
  c.href = getMapURL(o.sid);
  c.title = `Copy Map URL (#${o.sid})`
  c.onclick = copyLink;
  c.innerHTML = '<i class="fa fa-link"></i>';

  c = popup.querySelector('#popup-wiki-link');
  c.href = getWikiURL(info.title);
  c.title = `Open Wiki ("${info.title}")`;
  c.onclick = null;
  c.innerHTML = '<i class="fa-brands fa-wikipedia-w"></i>';

  c = popup.querySelector('#popup-found');
  c.checked = settings.markedItems[o.sid]==true;
  c.onclick = function() { toggleMarked(o.sid) };
  popup.querySelector('#popup-found-label').textContent = lang['sid_misc_pda_hint_HidePlayerLandmark'] || 'Found';

  let contentElement = popup.firstElementChild;

  e.target._infoWindow.setOptions({custom: true, dy: 16});
  e.target._infoWindow.setContent(contentElement);

  contentElement.addEventListener('contextmenu', function(e) { e.stopPropagation()}, true); // enable default context menu
}

function toggleMarked(id) {

  if (settings.markedItems[id]) {
    delete settings.markedItems[id];
  } else {
    settings.markedItems[id] = true;
  }

  for (m of markersData) {
    let marker = m.marker;
    let o = marker.feature.properties;
    if (id == o.sid) {
      let found = settings.markedItems[id];
      if (!(marker.getSymbol() instanceof Array)) {
        marker.updateSymbol({markerOpacity: found ? foundOpacity : 1 });
      }

      break;
    }
  }

  saveSettings();
}

function isLocked(o) {
  // all doors are closed by default unless it's DoorView without locked property
  let door = o.name=='EMarkerType::DynamicObject' || o.name=='EMarkerType::Door';
  let doorview = door && o.uaid && o.uaid.startsWith('BP_DoorView');
  return doorview ? o.locked : door;
}

function isNPC(o) {
  // all doors are closed by default unless it's DoorView without locked property
  return o.type=='ESpawnType::Obj' && o.proto=='QuestNPCBase';
}


// Function to show the tooltip
function showTooltip(e) {

  //if (e.target.feature.properties.description.includes('Region')) return;

  var tooltip = document.getElementById('map-tooltip');

  clearTimeout(tooltipHideTimer);

  tooltip.onmouseover = function(e) {
    clearTimeout(tooltipHideTimer);
  };

  tooltip.onmouseout = function(e) {
    tooltipHideTimer = setTimeout(hideTooltip, tooltipHideDelay);
  };


  // Show the tooltip to calculate the size
  // Since browsers do not repaint the screen during synchronous JavaScript execution,
  // temporarily changing the display property within a script will not cause the element to flash visibly on the screen.

  if (tooltip.style.display == 'block') return;

  tooltip.style.display = 'block';

  let marker = e.target;

  let o = marker.feature.properties;

  let info = renderItem(marker.feature, true);

  let content = `<b title="${o.name}">${info.title}</b>`;

  if (info.category) {
    content += `<br/><small>${info.category}</small>`;
  }

  if (info.description) {
    content += `<hr/>${info.description}`;
  }

  if (o.keycode) {
    content += `<hr/>${o.keycode}`;
  }

  if (o.items) {
    content += `<hr/><div class="overflow-container">`;
    for (const name of o.items) {
      let title = translate_item(name);
      content += `<span title="${name}">[${title}]</span><br/>`;
    }
    content +='</div>';
  }

  if (info.upgrade) {
    content += `<hr/>${info.upgrade}`;
  }

  if (info.quest) {
    content += `<hr/><div class="overflow-container small">${info.quest}</div>`;
  }

  if (info.note) {
    content += `<hr/>${info.note}`;
  }

  if (o.references) {
    let signals = o.references.join('\n');
    content += `<hr><div title="${signals}"><i class="fa-solid fa-code-commit"></i> ${o.references.length}</div>`;
  }

  tooltip.innerHTML = content;

  let c = marker.getContainerExtent();
  let screenPosition = {x: c.pxmin, y: c.pymin};

  // Determine the tooltip position
  var mapContainer = map.getContainer();
  var mapRect = mapContainer.getBoundingClientRect();
  var tooltipWidth = tooltip.offsetWidth;
  var tooltipHeight = tooltip.offsetHeight;

  // Calculate available space
  var spaceRight = mapRect.width - screenPosition.x;
  var spaceLeft = screenPosition.x;

  let gap = getMarkerSize(marker)/2+5;

  // Position the tooltip
  if (spaceRight > tooltipWidth) {
    // Place tooltip to the right
    tooltip.style.left = mapRect.left + screenPosition.x + gap + 'px';
    tooltip.className = 'arrow-left';
  } else {
    // Place tooltip to the left
    tooltip.style.left =  mapRect.left + screenPosition.x - tooltipWidth - gap + 'px';
    tooltip.className = 'arrow-right';
  }

  tooltip.style.top = mapRect.top + screenPosition.y - tooltipHeight/2 + 'px';

}

// Function to hide the tooltip
function hideTooltip() {
  var tooltip = document.getElementById('map-tooltip');
  tooltip.style.display = 'none';
  clearSelection();
}

function getIconName(o) {
  return getIconProp(o).icon;
}

function getIconProp(o) {
  let prop = {icon: 'question', group: 'misc'};

  let section = types[o.type];

  prop = {...prop, ...section};

  if (section && section.items) {
    for (field of [o.subtype, o.name, o.proto]) {
      let t = section.items[field];
      if (t) return t;
    }
  }

  if (section && section.match) {
    for (const [regex, entry] of Object.entries(section.match)) {
      if (regex && (o.name ||'').match(new RegExp(regex, ""))) return entry;
      if (regex && (o.proto||'').match(new RegExp(regex, ""))) return entry;
    }
  }

  return prop;
}

function showTooltipExt(e) {
  let marker = e.target;
  //setMarkerSize(e.target, size * 1.15);
  clearTimeout(tooltipShowTimer);

  if (marker.getInfoWindow() && marker.getInfoWindow().isVisible()) return; // do not open popup if there's an info window

  //tooltipShowTimer = setTimeout(showTooltip, tooltipShowDelay, e);

  showTooltip(e); // parameter bug
}

function hideTooltipExt(e) {
  let marker = e.target;
  //setMarkerSize(e.target, size * 1.0);
  clearTimeout(tooltipShowTimer);
  clearTimeout(tooltipHideTimer);
  tooltipHideTimer = setTimeout(hideTooltip, tooltipHideDelay);
}

dedup = {};

function addMarker(feature) {
  let o = feature.properties;

  if (o.area && !o.area.includes('WorldMap_WP')) return null;
  if (o.name=='Hub') return null; // 1 marker (special case)

  let info = renderItem(feature);

  let prop = info.prop;

  let icon = prop.icon || 'question';
  let group = prop.group || 'misc';

  // clue is always a stash
  if (o.clue) icon = 'stash';
  if (icon=='stash') group = 'stashes';

  if (isLocked(o)) icon='circle-dot';
  
  if (icon=='question' && isNPC(o)) icon='soldier';

  image = 'images/sprites/' + ((icons[icon] && icons[icon].image) || 'CompassMarker_2_3.png');

  let size = iconSize;

  if (image.includes('CompassMarker')) {
    size = 32;
  }

  let found = settings.markedItems[o.sid];
  let opacity = found ? foundOpacity : 1;

  let symbol = {
    markerFile   : image,
    markerWidth  : size,
    markerHeight : size,
    markerDx     : 0,
    markerDy     : 0,
    markerOpacity: opacity,
    markerVerticalAlignment: 'middle',
  };

  let title  = info.title;

  let markerDx = 0;
  let markerDy = 0;
  let textDx = iconSize * 0.55;
  let textDy = 0;

  if (group=='regions') {
    textDx = 16;
  }

  if (labelGroups.includes(group)) {
    symbol = [
       {
        markerFile   : image,
        markerWidth  : size,
        markerHeight : size,
        markerDx     : markerDx,
        markerDy     : markerDy,
        markerOpacity: opacity,
        markerVerticalAlignment: 'middle',
      },
      {
        textFaceName : 'sans-serif',
        textName : title,
        textFill : '#fff',

        textHaloFill      : '#000',
        textHaloRadius    : 3,
        textHaloOpacity   : 0.15,

        textHorizontalAlignment : 'right',
        textSize : textSize,
        textDx: textDx,
        textDy: textDy,
      },
    ]
  }

  //c = {x: c[0], y:c[1], z:c[2] };
  //c = scaleAltitude(c);

  let c = feature.geometry.coordinates;
  c = scaleCoordinateArray(c);

  var marker = new maptalks.Marker(c, {symbol: symbol});

  marker.feature = feature;

  // hub markers seem to use average coordinates
  // so we check the dedup structure if we have the marker then adjust coordinates accordingly
  if (o.type=='ESpawnType::Hub') {
    let key = o.type + o.name;
    if (dedup[key]) {
      let marker = dedup[key];
      function average(a,b) {
        return [ (a.x+b.x)/2, (a.y+b.y)/2, (a.z+b.z)/2 ];
      };
      marker.setCoordinates(average(marker.getCoordinates(), {x: c[0], y: c[1], z:c[2]}));
      return null;
    }
    dedup[key] = marker;
  }

  // deduplicate bulba anomaly (it's BulbArchAnomaly vs sid_locations_archanomaly_bulba_name but titles are the same)
  if (o.type=='ESpawnType::Marker') {
    let key = o.type + o.title;
    if (dedup[key]) {
      //console.log(key);
      return null;
    }
    dedup[key] = marker;
  }

  marker.on('mouseover', showTooltipExt);
  marker.on('mouseout', hideTooltipExt);

  //marker.on('click', popupOnClick);

  //const tooltip = new CustomTooltip(info.title,{}).addTo(marker);

/*
  // this shit eats 200 ms. find a way to use a single tooltip
  //let tooltipTitle = `${info.title} (${info.category})`;
  let tooltipTitle = info.title;
  const tooltip = new maptalks.ui.ToolTip(tooltipTitle, {
    showTimeout: 1,
  }).addTo(marker);
*/
  marker.setInfoWindow({autoCloseOn: 'click'})
  //.on('dragend', onDragEnd)
  .on('click', popupOnClick)
  .on('contextmenu', e=> {
    //if (mouseMoved) return;
    //let o = e.target.properties;
    //toggleMarked(o.ref_id);
  })

  if (o.actors) {
    for(const uaid of o.actors) {
      actors_lookup[uaid] = marker;
    }
  }

  if (o.items) {
    for(const name of o.items) {
      if (!items_lookup[name]) items_lookup[name] = [];
      items_lookup[name].push(marker);
    }
  }

  return {group: group, marker: marker};
}

function scaleOrigin(coordinates, scaleFactor, origin) {
  return coordinates.map(coord => {
    const [x, y] = coord;
    return [
      origin[0] + (x - origin[0]) * scaleFactor,
      origin[1] + (y - origin[1]) * scaleFactor,
      -10, // sink region outline a bit (some markers are -3)
    ];
  });
}

function scaleGeoJSON(geojson, scaleFactor, origin) {
  geojson.features.forEach(feature => {
    feature.geometry.coordinates = feature.geometry.coordinates.map(ring =>
      scaleOrigin(ring, scaleFactor, origin)
    );
  });
  return geojson;
}


function updateView(e) {
  let zoom = map.getZoom();
  if (settings.searchText!='') {
    return;
  }

  for(const [layerName, zoomLevel] of Object.entries(zoomGroups)) {
    let layer = groupLayer.getLayer(capitalize(layerName));
    if (layer) {
      let [minZoom, maxZoom] = zoomLevel;
      if (zoom>=minZoom+0.5 && zoom < maxZoom+0.5) {
        layer.show();
      } else {
        layer.hide();
      }
    }
  }
}

function isPointInsidePolygon(point, polyPoints) {
  let [x,y] = [point.x, point.y];
  let inside = false;
  for (let i = 0, j = polyPoints.length - 1; i < polyPoints.length; j = i++) {
    var xi = polyPoints[i].x, yi = polyPoints[i].y;
    var xj = polyPoints[j].x, yj = polyPoints[j].y;
    var intersect = ((yi > y) != (yj > y))
        && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
    if (intersect) inside = !inside;
  }
  return inside;
};

function getRegionName(coord, polygons) {
  if (!polygons || !coord) return null;
  for (const polygon of polygons) {
    if (isPointInsidePolygon(coord, polygon.getCoordinates()[0])) {
      return polygon.properties.svgID.substring(1);
    }
  }
}

function addRegions(geojson) {
  const defaultSymbol = {
    'lineColor': '#fff',    // Border color
    'lineWidth': 1.5,            // Border width
    'polygonFill': '#fff',  // Fill color
    'polygonOpacity': 0.0,      // Fill opacity
    'lineOpacity': 0.5,
  };

  // Define the hover style
  const hoverSymbol = {
    'polygonOpacity': 0.20 // Increased opacity
  };

  const polygons = maptalks.GeoJSON.toGeometry(scaleGeoJSON(geojson, 812900/8192, [0,0]));

  // Store a reference to the currently "hovered" polygon
  let selectedPolygon = null;
  let lastZoom = null;

  let polygonClick = e=> {
    if (selectedPolygon) {
      const extent = selectedPolygon.getExtent();
      let zoom = map.getZoom();
      if (extent && zoom <= 4) {
        //map.fitExtent(extent);
        const center = extent.getCenter();
        map.animateTo({center: center, zoom: 4});
      }
    }
  }

  polygons.forEach(polygon => {
    if (polygon.getType() === 'Polygon') { // Ensure it's a polygon
      polygon.setSymbol(defaultSymbol);
      let name = polygon.properties.svgID.substring(1).replaceAll('_','');
      polygon.feature = {properties: {title: name}};
      //polygon.on('click', polygonClick); // doesn't work with overlapping labels, use global event for now
    }
  });

  regionsData = polygons;

  map.on('click', polygonClick);

  // Add mousemove listener to the map
  map.on('mousemove', e => {

    let zoom = map.getZoom();
    let maxZoom = 3;

    const mouseCoord = e.coordinate; // Geographic coordinate of the mouse
    //let mouseCoord = map.containerPointToCoord(e.containerPoint); // same

    let found = false;

    // Iterate through polygons to find if the point is inside any
    for (const polygon of polygons) {

      if (!polygon.isVisible()) continue;

      //if (polygon.containsPoint(mouseCoord)) { // doesn't work for some reason
      if (isPointInsidePolygon(mouseCoord, polygon.getCoordinates()[0])) {

        found = true;

        if (selectedPolygon !== polygon || lastZoom != zoom) {
          // New polygon hovered, update appearance
          if (selectedPolygon) {
            // Reset the previous polygon
            selectedPolygon.updateSymbol(defaultSymbol);
          }

          // Highlight the currently hovered polygon
          polygon.updateSymbol(zoom > maxZoom ? defaultSymbol : hoverSymbol);
          selectedPolygon = polygon; // Update reference

          currentRegion = polygon.properties.svgID.substring(1);

          if (zoom>maxZoom) selectedPolygon = null; // uncomment to prevent zoom on click (it's rather glitchy)

          lastZoom = zoom;
        }
        break; // Stop checking once a match is found
      }
    }

    if (!found && selectedPolygon) {
      // Mouse is not over any polygon, reset the previous one
      selectedPolygon.updateSymbol(defaultSymbol);
      selectedPolygon = null; // Clear reference
    }
  });

  let layerId = 'Polygons'
  let visible = settings.activeItems[layerId.toLowerCase()] == true;
  let layer = new maptalks.PolygonLayer(layerId, polygons, { visible: visible });
  addHandler(layer);
  layer.addTo(groupLayer);
}

function saveSettings() {
  localStorage.setItem(localDataName, JSON.stringify(localData));
}

function passesFilter(marker) {
  // will be replaced with fuzzy search
  let text = settings.searchText && settings.searchText.toLowerCase() || '';

  if (!text) return true;

  let terms = text.split(' ');
  let o = marker.feature.properties;
  let tags = [];

  let info = renderItem(marker.feature, true);

  // little hack before fuse.js, use 2 for exact match
  if (o.sid && o.sid.toLowerCase() == text) return 2;
  if (info.title && info.title.toLowerCase() == text) return 2;

  if (o.spawns) tags.push(...o.spawns);
  if (o.references) tags.push(...o.references);
  if (o.actors) tags.push(...o.actors);
  if (o.items) tags.push(...o.items);

  if (o.keycode) tags.push('keycode');
  if (o.items) tags.push('items');
  if (o.clue) tags.push('clue');

  for (p of [o.lock, o.enable, o.keycode, o.uaid]) {
    if (p) tags.push(p);
  }

  for (name of (info.items||[])) {
    tags.push(name);
  }

  // spawn items (all titles and names)
  for (const prop of info.groups||[]) {
    let name = prop.name;
    let title = translate_item(name);
    tags.push(name);
    tags.push(title);
  }

  let s = [o.title, o.name, o.type, o.description, o.sid, o.clue, o.cell, o.proto, o.material,

    info.title,
    info.category,
    info.group,
    info.description,
    info.upgrade,
    info.description,
    info.quest,
    info.note,
    //info.location, // maybe don't do location, too many matches

    ...tags].map(x=>x||'').join(' ').toLowerCase();

  return !(text!='' && !terms.every(term=>s.includes(term)));
}

function updatePopup() {
  for (const layer of groupLayer.getLayers()) {
    for (marker of layer._geoList) {
      if (marker.getInfoWindow() && marker.getInfoWindow().isVisible()) {
        popupOnClick({target: marker});
        marker.openInfoWindow();
      }
    }
  }
}

function filterItems() {
  let count = 0;
  let target = null;

  for (const layer of groupLayer.getLayers()) {
    //if (!layer.isVisible()) continue; // skip hidden layers altogether (for now)
    for (marker of layer._geoList) {
      let res = passesFilter(marker);
      if (res){

        if (res==2) {
          target = marker;
        }

        marker.show();
        let parent = marker.getLayer();
        if (parent && !parent.isVisible())
          parent.show();
          count += 1;
      } else {
        marker.hide();
      }
    }
  }

  searchControl = document.querySelector('.search-box input');
  searchControl.title = `${count} markers`;

  return target;
}

function clearFilter() {
  searchControl.value = '';
  settings.searchText = '';
  filterItems();
}

function updateSearch(text, updateControl=true) {
  if (updateControl) {
    searchControl.value = text;
  }

  settings.searchText = text;

  if (text=='') {

    clearFilter();
    updateView();

  } else {
    let marker = filterItems();
    if (marker) {
      //map.setView({center: marker.getCoordinates()}); // optional, it gets into view anyway
      popupOnClick({target: marker});
      marker.openInfoWindow();
    }
  }

  saveSettings();
}


function applyTint(src, r,g,b, callback) {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  const img = new Image();
  img.crossOrigin = 'Anonymous';
  img.src = src;
  img.onload = () => {
    canvas.width = img.width;
    canvas.height = img.height;
    ctx.drawImage(img, 0, 0);
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;
    for (let i = 0; i < data.length; i += 4) {

      data[i + 0] = data[i + 0] * r / 255;
      data[i + 1] = data[i + 1] * g / 255;
      data[i + 2] = data[i + 2] * b / 255;

    }
    ctx.putImageData(imageData, 0, 0);
    canvas.toBlob((blob) => {
      callback(blob);
    }, 'image/png');
  };
}

window.onload = function(event) {

  if (location.hash.length>1) {
    let param = decodeURIComponent(location.hash.slice(1));
    mapParam.markerName = param;
    mapParam.mapId = mapId;
  }

  try {
  // clear location hash
    history.pushState('', document.title, window.location.pathname + window.location.search);
  } catch(error) {
    console.log('handled error', error);
  }

  loadMap();

  let compassControl = new maptalks.control.Compass({position  : 'bottom-right'}).addTo(map)
    ._compass.onclick = (e)=>map.getBearing()==0 && map.animateTo({ pitch: map.getPitch()==0 ? defaultPitch : 0 })

  window.addEventListener("keydown",function (e) {

    if (e.code == 'Escape' || e.code == 'Enter') {
      if (e.code=='Escape') {
        document.querySelector('#map').focus();
      }
      updateSearch(searchControl.value||'', false);
      return;
    }

    if (document.activeElement != document.querySelector('#map')) {
      return;
    }

    if (e.code=='KeyF' && e.ctrlKey) {
      searchControl.focus();
      e.preventDefault();
      return;
    }

    if (e.code=='KeyR' && !e.ctrlKey) {
      if (map.getBearing()!=0) {
        map.animateTo({ bearing: 0 });
      } else {
        map.animateTo({ pitch: map.getPitch()==0 ? defaultPitch : 0 });
      }
    }

  });

  let rank = settings.rank || 'Master';
  let rank_list = [ 'Newbie', 'Experienced', 'Veteran', 'Master' ];
  let rankSelect = document.querySelector('#rank-selector select');
  rankSelect.innerHTML = rank_list.map(x=>`<option${rank==x?' selected':''}>${x}</option>`).join('');
  rankSelect.onchange = e=> {
    settings.rank = e.target.value;
    saveSettings();
    updatePopup();
  };

  let cc = settings.language || 'en';
  let cc_list = ['ua','en','ru'];
  let langSelect = document.querySelector('#language-selector select');
  langSelect.innerHTML = cc_list.map(x=>`<option${cc==x?' selected':''}>${x}</option>`).join('');
  langSelect.onchange = e=> {
    settings.language = e.target.value;
    saveSettings();
    location.reload();
  };


  fetch(`data/Localization/Localization_${cc.toUpperCase()}.json`).then(r=>r.json()).then(data=>{
    lang = data;
    document.querySelector('.search-box input').setAttribute('placeholder', lang['sid_misc_hint_loot'] +'...');

    let promises = [
      'data/types.json',
      'data/icons.json',
      'data/regions.json',
      'data/markers.json',
    ].map(url=>fetch(url).then(r=>r.json()));

    Promise.all(promises).then(data => {
      [types, icons, regions, markers] = data;
      loadMarkers(markers);
    });

  });


};

</script>

<a href="https://github.com/joric/maps/wiki/Stalker-2" target="_blank" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

</body>
</html>

<!--script src="https://cdn.jsdelivr.net/npm/eruda"></script><script>eruda.init();</script-->

